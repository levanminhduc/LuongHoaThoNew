import { type NextRequest, NextResponse } from "next/server"
import { createServiceClient } from "@/utils/supabase/server"
import jwt from "jsonwebtoken"

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key-change-this-in-production"

// Verify admin token
function verifyAdminToken(request: NextRequest) {
  const authHeader = request.headers.get("authorization")
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return null
  }

  const token = authHeader.substring(7)
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any
    return decoded.role === "admin" ? decoded : null
  } catch {
    return null
  }
}

export async function GET(request: NextRequest) {
  try {
    console.log("üîç Search API called:", {
      url: request.url,
      timestamp: new Date().toISOString()
    })

    // Verify admin authentication
    const admin = verifyAdminToken(request)
    if (!admin) {
      console.log("‚ùå Authentication failed")
      return NextResponse.json({ error: "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p" }, { status: 401 })
    }

    console.log("‚úÖ Admin authenticated:", admin.username)

    const { searchParams } = new URL(request.url)
    const query = searchParams.get("q")
    const salaryMonth = searchParams.get("salary_month")

    console.log("üìã Search params:", { query, salaryMonth })

    if (!query || query.length < 2) {
      console.log("‚ùå Invalid query length")
      return NextResponse.json(
        { error: "T·ª´ kh√≥a t√¨m ki·∫øm ph·∫£i c√≥ √≠t nh·∫•t 2 k√Ω t·ª±" },
        { status: 400 }
      )
    }

    const supabase = createServiceClient()
    console.log("üì° Supabase client created")

    // Test basic database connectivity first
    try {
      const { data: testData, error: testError } = await supabase
        .from("employees")
        .select("employee_id")
        .limit(1)

      console.log("üîå Database connectivity test:", {
        success: !testError,
        hasData: !!testData,
        error: testError
      })

      if (testError) {
        console.error("‚ùå Database connectivity failed:", testError)
        return NextResponse.json({
          error: "Kh√¥ng th·ªÉ k·∫øt n·ªëi database. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh.",
          debug: process.env.NODE_ENV === "development" ? testError : undefined
        }, { status: 500 })
      }
    } catch (connectError) {
      console.error("‚ùå Database connection exception:", connectError)
      return NextResponse.json({
        error: "L·ªói k·∫øt n·ªëi database nghi√™m tr·ªçng.",
        debug: process.env.NODE_ENV === "development" ? connectError : undefined
      }, { status: 500 })
    }

    // First, check if tables have data using correct Supabase syntax
    console.log("üîç Checking table data...")

    const { count: payrollCount, error: payrollCountError } = await supabase
      .from("payrolls")
      .select("*", { count: "exact", head: true })

    const { count: employeeCount, error: employeeCountError } = await supabase
      .from("employees")
      .select("*", { count: "exact", head: true })

    console.log("üìä Data check:", {
      payrollCount: payrollCount || 0,
      employeeCount: employeeCount || 0,
      payrollCountError,
      employeeCountError
    })

    // If count queries fail, try simple existence check
    if (payrollCountError || employeeCountError) {
      console.log("‚ö†Ô∏è Count queries failed, trying simple existence check...")

      const { data: payrollExists, error: payrollExistsError } = await supabase
        .from("payrolls")
        .select("id")
        .limit(1)

      const { data: employeeExists, error: employeeExistsError } = await supabase
        .from("employees")
        .select("employee_id")
        .limit(1)

      console.log("üìä Existence check:", {
        payrollExists: !!payrollExists && payrollExists.length > 0,
        employeeExists: !!employeeExists && employeeExists.length > 0,
        payrollExistsError,
        employeeExistsError
      })

      // If existence check also fails, there's a fundamental access issue
      if (payrollExistsError || employeeExistsError) {
        console.error("‚ùå Database access failed:", {
          payrollError: payrollExistsError,
          employeeError: employeeExistsError
        })

        return NextResponse.json({
          error: "L·ªói truy c·∫≠p database. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh RLS policies.",
          debug: process.env.NODE_ENV === "development" ? {
            payrollError: payrollExistsError,
            employeeError: employeeExistsError
          } : undefined
        }, { status: 500 })
      }

      // Use existence check results
      if (!payrollExists || payrollExists.length === 0) {
        return NextResponse.json({
          success: true,
          results: [],
          total: 0,
          message: "Ch∆∞a c√≥ d·ªØ li·ªáu l∆∞∆°ng trong h·ªá th·ªëng. Vui l√≤ng import d·ªØ li·ªáu tr∆∞·ªõc."
        })
      }

      if (!employeeExists || employeeExists.length === 0) {
        return NextResponse.json({
          success: true,
          results: [],
          total: 0,
          message: "Ch∆∞a c√≥ d·ªØ li·ªáu nh√¢n vi√™n trong h·ªá th·ªëng. Vui l√≤ng import d·ªØ li·ªáu tr∆∞·ªõc."
        })
      }
    }

    // If no data exists, return helpful message
    if (!payrollCount || payrollCount.length === 0) {
      return NextResponse.json({
        success: true,
        results: [],
        total: 0,
        message: "Ch∆∞a c√≥ d·ªØ li·ªáu l∆∞∆°ng trong h·ªá th·ªëng. Vui l√≤ng import d·ªØ li·ªáu tr∆∞·ªõc."
      })
    }

    if (!employeeCount || employeeCount.length === 0) {
      return NextResponse.json({
        success: true,
        results: [],
        total: 0,
        message: "Ch∆∞a c√≥ d·ªØ li·ªáu nh√¢n vi√™n trong h·ªá th·ªëng. Vui l√≤ng import d·ªØ li·ªáu tr∆∞·ªõc."
      })
    }

    // Search employees with their payroll data
    // Use left join to avoid RLS issues and handle missing employee data gracefully
    console.log("üîç Building query...")
    let payrollQuery = supabase
      .from("payrolls")
      .select(`
        id,
        employee_id,
        salary_month,
        tien_luong_thuc_nhan_cuoi_ky,
        source_file,
        created_at,
        employees(
          employee_id,
          full_name,
          department,
          chuc_vu,
          is_active
        )
      `)
      .not("employees.is_active", "is", null)
      .eq("employees.is_active", true)
      .or(`employee_id.ilike.%${query}%`)
      .order("created_at", { ascending: false })

    console.log("üìä Query built, adding filters...")

    // Filter by salary month if provided
    if (salaryMonth && salaryMonth !== "__EMPTY__") {
      console.log("üìÖ Adding month filter:", salaryMonth)
      payrollQuery = payrollQuery.eq("salary_month", salaryMonth)
    }

    console.log("üöÄ Executing query...")
    const { data: payrollData, error: payrollError } = await payrollQuery.limit(20)

    console.log("üìä Query result:", {
      hasData: !!payrollData,
      dataLength: payrollData?.length || 0,
      hasError: !!payrollError,
      error: payrollError
    })

    // If main query fails, try alternative approach
    if (payrollError) {
      console.log("üîÑ Main query failed, trying alternative approach...")

      // Try simple query without join first
      const { data: simpleData, error: simpleError } = await supabase
        .from("payrolls")
        .select("id, employee_id, salary_month, tien_luong_thuc_nhan_cuoi_ky, source_file, created_at")
        .ilike("employee_id", `%${query}%`)
        .limit(20)

      if (simpleError) {
        console.error("‚ùå Simple query also failed:", simpleError)
      } else {
        console.log("‚úÖ Simple query succeeded:", simpleData?.length || 0, "records")

        // If simple query works, the issue is with the join
        if (simpleData && simpleData.length > 0) {
          // Get employee data separately
          const employeeIds = simpleData.map(p => p.employee_id)
          const { data: employeeData } = await supabase
            .from("employees")
            .select("employee_id, full_name, department, chuc_vu, is_active")
            .in("employee_id", employeeIds)

          // Manually join the data
          const joinedData = simpleData.map(payroll => ({
            ...payroll,
            employees: employeeData?.find(emp => emp.employee_id === payroll.employee_id) || null
          }))

          console.log("‚úÖ Manual join completed")

          // Use the manually joined data
          const results = joinedData.filter(record => record.employees).map(record => ({
            payroll_id: record.id,
            employee_id: record.employee_id,
            full_name: record.employees?.full_name || "N/A",
            department: record.employees?.department || "N/A",
            position: record.employees?.chuc_vu || "N/A",
            salary_month: record.salary_month,
            net_salary: record.tien_luong_thuc_nhan_cuoi_ky || 0,
            source_file: record.source_file || "N/A",
            created_at: record.created_at
          }))

          return NextResponse.json({
            success: true,
            results,
            total: results.length,
            note: "Used alternative query method"
          })
        }
      }
    }

    if (payrollError) {
      console.error("Error searching payroll data:", {
        error: payrollError,
        query,
        salaryMonth,
        timestamp: new Date().toISOString()
      })

      // Provide more specific error messages
      let errorMessage = "L·ªói khi t√¨m ki·∫øm d·ªØ li·ªáu l∆∞∆°ng"

      if (payrollError.code === "PGRST116") {
        errorMessage = "L·ªói k·∫øt n·ªëi database. Vui l√≤ng th·ª≠ l·∫°i sau."
      } else if (payrollError.code === "42501") {
        errorMessage = "L·ªói quy·ªÅn truy c·∫≠p database. Vui l√≤ng li√™n h·ªá admin."
      } else if (payrollError.message?.includes("relation") || payrollError.message?.includes("table")) {
        errorMessage = "L·ªói c·∫•u tr√∫c database. Vui l√≤ng li√™n h·ªá admin."
      } else if (payrollError.message?.includes("RLS")) {
        errorMessage = "L·ªói b·∫£o m·∫≠t database. Vui l√≤ng li√™n h·ªá admin."
      }

      return NextResponse.json(
        {
          error: errorMessage,
          debug: process.env.NODE_ENV === "development" ? payrollError : undefined
        },
        { status: 500 }
      )
    }

    // Transform data for frontend with null safety
    const results = payrollData?.filter(record => {
      // Filter out records without employee data (due to RLS or missing data)
      return record.employees && record.employees.full_name
    }).map(record => ({
      payroll_id: record.id,
      employee_id: record.employee_id,
      full_name: record.employees?.full_name || "N/A",
      department: record.employees?.department || "N/A",
      position: record.employees?.chuc_vu || "N/A",
      salary_month: record.salary_month,
      net_salary: record.tien_luong_thuc_nhan_cuoi_ky || 0,
      source_file: record.source_file || "N/A",
      created_at: record.created_at
    })) || []

    return NextResponse.json({
      success: true,
      results,
      total: results.length
    })

  } catch (error) {
    console.error("‚ùå Employee search error:", {
      error: error instanceof Error ? error.message : error,
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString()
    })

    return NextResponse.json(
      {
        error: "C√≥ l·ªói x·∫£y ra khi t√¨m ki·∫øm nh√¢n vi√™n",
        debug: process.env.NODE_ENV === "development" ? {
          message: error instanceof Error ? error.message : String(error),
          type: error instanceof Error ? error.constructor.name : typeof error
        } : undefined
      },
      { status: 500 }
    )
  }
}

// GET available salary months
export async function POST(request: NextRequest) {
  try {
    // Verify admin authentication
    const admin = verifyAdminToken(request)
    if (!admin) {
      return NextResponse.json({ error: "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p" }, { status: 401 })
    }

    const supabase = createServiceClient()

    // Get distinct salary months
    const { data: monthsData, error: monthsError } = await supabase
      .from("payrolls")
      .select("salary_month")
      .order("salary_month", { ascending: false })

    if (monthsError) {
      console.error("Error fetching salary months:", {
        error: monthsError,
        timestamp: new Date().toISOString()
      })

      let errorMessage = "L·ªói khi l·∫•y danh s√°ch th√°ng l∆∞∆°ng"

      if (monthsError.code === "42501") {
        errorMessage = "L·ªói quy·ªÅn truy c·∫≠p. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i."
      } else if (monthsError.code === "PGRST116") {
        errorMessage = "L·ªói k·∫øt n·ªëi database. Vui l√≤ng th·ª≠ l·∫°i sau."
      }

      return NextResponse.json(
        {
          error: errorMessage,
          debug: process.env.NODE_ENV === "development" ? monthsError : undefined
        },
        { status: 500 }
      )
    }

    // Get unique months
    const uniqueMonths = [...new Set(monthsData?.map(item => item.salary_month) || [])]

    return NextResponse.json({
      success: true,
      months: uniqueMonths
    })

  } catch (error) {
    console.error("Salary months fetch error:", error)
    return NextResponse.json(
      { error: "C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch th√°ng l∆∞∆°ng" },
      { status: 500 }
    )
  }
}
